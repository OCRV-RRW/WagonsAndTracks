local camera_orto = require("orthographic.camera")
local event_bus = require('main.modules.event_bus_module')
local GAME_STATE = require('main.modules.game_state')
Dynamic_Path = require("main.classes.dynamic_path")

go.property('path_count', 2)

local function get_destination_pos(self, collision_object_id, wagon)
	local destination_point_id = self.obj:get_destination_point(collision_object_id)
	msg.post(msg.url(destination_point_id), 'disable_collision')
	if not destination_point_id then
		msg.post(wagon, 'delete_obj', {right = false})
	end
	return go.get_world_position(destination_point_id)
end

local function get_help_pos(self)
	return go.get_world_position(go.get_id('help_point'))
end

local function pick(self, touch_pos)
	local size = go.get("#sprite", "size")
	local world_pos = camera_orto.screen_to_world(hash("/camera"), touch_pos)
	local go_world_pos = go.get_world_position()
	if world_pos.x >= (go_world_pos.x - size.x / 2) and world_pos.x <= (go_world_pos.x + size.x / 2) then
		if world_pos.y >= (go_world_pos.y - size.y / 2) and world_pos.y <= (go_world_pos.y + size.y / 2) then
			return true
		end
	end
	return false
end 

local function change_state(self)
	self.obj:toggle_state()
	local new_state = self.obj:get_state()
	if self.path_count == 2 then
		if new_state == 1 then
			sprite.play_flipbook('#sprite', 'double_dynamic_path_direction_cell')
		elseif new_state == 2 then
			sprite.play_flipbook('#sprite', 'double_dynamic_path_forward_cell')
		end
	end
	if self.path_count == 3 then
		if new_state == 1 then
			sprite.play_flipbook("#sprite", "triple_dynamic_path_direction2_cell")
		elseif new_state == 2 then
			sprite.play_flipbook("#sprite", "triple_dynamic_path_forward_cell")
		elseif new_state == 3 then
			sprite.play_flipbook("#sprite", "triple_dynamic_path_direction_cell")
		end
	end
end

function init(self)
	msg.post(".", "acquire_input_focus")
	self.is_clickable = true
	self.on_level_pause_handler = function ()
		self.is_clickable = false
	end

	self.on_level_finish_handler = function ()
		self.is_clickable = false
	end

	self.on_level_resume_handler = function ()
		self.is_clickable = true
	end

	local point_id = go.get_id('path_point')
	local point1_id = go.get_id('path_point1')
	local point2_id = go.get_id('path_point2')
	msg.post(point_id, 'set_path')
	msg.post(point1_id, 'set_path')
	msg.post(point2_id, 'set_path')
	local points = {}
	points[1] = point1_id
	points[2] = point2_id
	if self.path_count == 3 then
		local point3_id = go.get_id('path_point3')
		msg.post(point3_id, 'set_path')
		points[3] = point3_id
	end
	self.obj = Dynamic_Path(self.path_count, point_id, point2_id, points)
	self.enter = false

	event_bus.EVENT_BUS:subscribe(GAME_STATE.EVENTS.on_level_pause, self.on_level_pause_handler)
	event_bus.EVENT_BUS:subscribe(GAME_STATE.EVENTS.on_level_resume, self.on_level_resume_handler)
	event_bus.EVENT_BUS:subscribe(GAME_STATE.EVENTS.on_finish_level, self.on_level_finish_handler)
end

function final(self)
	msg.post(".", "release_input_focus")
	self.is_clickable = false
	event_bus.EVENT_BUS:unsubscribe(GAME_STATE.EVENTS.on_level_pause, self.on_level_pause_handler)
	event_bus.EVENT_BUS:unsubscribe(GAME_STATE.EVENTS.on_level_resume, self.on_level_resume_handler)
	event_bus.EVENT_BUS:unsubscribe(GAME_STATE.EVENTS.on_finish_level, self.on_level_finish_handler)

	self.on_level_pause_handler = nil
	self.on_level_resume_handler = nil
	self.on_level_finish_handler = nil
end

function update(self, dt)
end

function fixed_update(self, dt)
end

function on_message(self, message_id, message, sender)
	if message_id == hash("on_wagon_collision") then
		msg.post(message.wagon, 'set_destination_pos', {destination_pos = get_destination_pos(self, message.go_id, message.wagon), 
			help_pos = get_help_pos(self)})
	end
end

function on_input(self, action_id, action)
	if not self.is_clickable then return end
	if action_id == hash("touch") and action.pressed then
		if pick(self, vmath.vector3(action.x, action.y, 0)) then
			change_state(self)
		end
	end
end

function on_reload(self)
end
